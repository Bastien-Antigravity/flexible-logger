package network_manager

import (
	"fmt"
	"io"
	"sync"
	"time"
)

// -----------------------------------------------------------------------------
// ManagedConnection wraps a connection and handles automatic reconnection.
type ManagedConnection struct {
	ip          *string
	port        *string
	publicIP    *string
	profile     string
	nm          *NetworkManager
	currentConn io.WriteCloser
	mu          sync.Mutex
}

// -----------------------------------------------------------------------------

func (mc *ManagedConnection) Write(p []byte) (n int, err error) {
	mc.mu.Lock()
	defer mc.mu.Unlock()

	// If no connection, try to reconnect immediately (blocking)
	if mc.currentConn == nil {
		if err := mc.reconnect(); err != nil {
			return 0, err
		}
	}

	n, err = mc.currentConn.Write(p)
	if err != nil {
		fmt.Printf("ManagedConnection: Write failed (%v). Reconnecting...\n", err)
		mc.currentConn.Close()
		mc.currentConn = nil

		// Reconnect and retry once
		if rErr := mc.reconnect(); rErr != nil {
			return 0, fmt.Errorf("write failed: %w; reconnect failed: %v", err, rErr)
		}
		return mc.currentConn.Write(p) // Retry
	}
	return n, nil
}

// -----------------------------------------------------------------------------

func (mc *ManagedConnection) Close() error {
	mc.mu.Lock()
	defer mc.mu.Unlock()
	if mc.currentConn != nil {
		return mc.currentConn.Close()
	}
	return nil
}

// -----------------------------------------------------------------------------

func (mc *ManagedConnection) reconnect() error {
	// Use NetworkManager's ConnectBlocking logic (but customized for internal use)
	// We loop indefinitely until connected, or maybe we should respect some context/timeout?
	// For "reliable" logger, blocking until success is usually expected behavior
	// (or at least better than dropping logs, though it blocks the caller).

	address := fmt.Sprintf("%s:%s", *mc.ip, *mc.port)
	delay := mc.nm.BaseDelay

	for {
		conn, err := mc.nm.EstablishConnection(mc.ip, mc.port, mc.publicIP, mc.profile)
		if err == nil {
			// Resolve address again just for logging if needed, or rely on EstablishConnection logic?
			// EstablishConnection doesn't return the resolved address. Let's resolve it here for the log msg.
			address = fmt.Sprintf("%s:%s", *mc.ip, *mc.port)
			fmt.Printf("ManagedConnection: Reconnected to %s\n", address)
			mc.currentConn = conn
			return nil
		}

		time.Sleep(delay)
		delay *= 2
		if delay > mc.nm.MaxDelay {
			delay = mc.nm.MaxDelay
		}
	}
}
